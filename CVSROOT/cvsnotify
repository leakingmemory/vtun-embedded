#!/usr/bin/perl -w

#*****************************************************************************
#!
#! FILE NAME  : cvsnotify
#!
#! PARAMETERS : -f <string>     - The string supplied by CVS that specifies
#!                                which repository and what files were
#!                                modified (use -f %{sVv} in the loginfo file).
#!              [-m <max>]      - The maximum number of lines to include in
#!                                the diff of the modified files. If it is
#!                                longer than this, it is not included at all.
#!                                The default is 100 lines.
#!              [-s <string>]   - Prepended to the subject line.
#!                                The default is "CVS: ".
#!              [-u]            - An unlimited number of lines can be included
#!                                from the diff of the modified files.
#!              recipient(s)    - List of those who should receive an e-mail
#!                                notification.
#!
#! DESCRIPTION: Parse a change message from CVS and send it as mail to
#!              the specified recipients.
#!
#! FUNCTIONS  : parse_files
#!              parse_message
#!              create_file_message
#!              send_mail
#!              encode_qp
#!
#!----------------------------------------------------------------------------
#! HISTORY
#!
#! $Log$
#! Revision 1.1  2001/09/26 07:13:16  pkj
#! Send change notifications to the bluez-commit list, except for
#! changes in CVSROOT which are only sent to Max and me.
#!
#!----------------------------------------------------------------------------
#! Copyright (C) 1999-2001, Axis Communications AB, LUND, SWEDEN
#!****************************************************************************
# $Id$

#****************** INCLUDE FILES SECTION ************************************

use strict;
use Getopt::Std;

#****************** VARIABLE DECLARATION SECTION *****************************

use vars qw($opt_f $opt_s $opt_m $opt_u);
use vars qw($pre_subject @users $files $log $max_diff_lines);
use vars qw($repository %files);

#****************** CONSTANT SECTION *****************************************

#****************** MAIN PROGRAM SECTION *************************************

getopts('f:s:m:u');

$pre_subject = $opt_s || "CVS: ";
$max_diff_lines = $opt_m || ($opt_u ? -1 : 100);

@users = @ARGV;
@ARGV = ();

die("No user(s) supplied!\n") if ($#users == -1);

die("No files(s) specified!\n") if (!($files = &parse_files($opt_f)));

# Read the log message from stdin.
$log = &parse_message($files == -1);

my($subject);
my($message) = &create_file_message();
if ($files == -1)
{
  $subject =
    "$pre_subject" .
    (scalar(keys(%files)) != 1 ?
     scalar(keys(%files)) . " files have" :
     "1 file has") .
    " been imported to $repository.";
}
elsif (keys(%files) == 1)
{
  # Only one file handled. Include the name of it in the subject.
  my($file) = (keys(%files))[0];
    
  $subject = "${pre_subject}The file '$repository/$file' has been ";

  if ($files{$file}{'old'} eq 'NONE')
  {
    $subject .= "added.";
  }
  elsif ($files{$file}{'new'} eq 'NONE')
  {
    $subject .= "removed.";
  }
  else
  {
    $subject .= "modified.";
  }
}
else
{
  # More than one file handled.
  $subject = "$pre_subject" . scalar(keys(%files)) .
    " files have been modified in $repository.";
}

send_mail($subject, $message, @users);

#****************** FUNCTION DEFINITION SECTION ******************************

#*****************************************************************************
##
## FUNCTION NAME: parse_files
##
## PARAMETERS   : $string - The string which CVS supplied us with that
##                          specifies which files were modified.
##
## RETURNS      : Number of files specified, or -1 if this was an import
##                notification.
##
## SIDE EFFECTS : None.
##
## DESCRIPTION  : Find out which files have changed and how.
##
##****************************************************************************

sub parse_files
{
  my($string) = @_;

  if ($string =~ /(.*) - Imported sources$/)
  {
    $repository = $1;
    return -1;
  }

  my(@tmp) = split(/\s+/, $string);

  $repository = shift(@tmp);

  my($file);
  foreach $file (@tmp)
  {
    if ($file =~ m/(.*),(.*),(.*)/)
    {
      $files{$1}{'name'} = $1;
      $files{$1}{'old'} = $2;
      $files{$1}{'new'} = $3;
    }
  }

  return scalar(keys(%files));
}

#*****************************************************************************
##
## FUNCTION NAME: parse_message
##
## PARAMETERS   : $importing - true if this is a message due to a 'cvs import'
##                             command, false otherwise.
##
## RETURNS      : The log message.
##
## SIDE EFFECTS : None.
##
## DESCRIPTION  : Extract the log message from stdin.
##
##****************************************************************************

sub parse_message
{
  my($importing) = @_;
  my($message);
  my($logging) = 0;
  my($tagging) = 0;
  my($fileing) = 0;
  my($vendor_tag);
  my($release_tag);

  while (<>)
  {
    chomp;
    if ($importing && $logging && /^Status:/)
    {
      print "Found status\n";
      $logging = 0;
      $tagging = 1;
    }
    elsif ($importing && $tagging && /^Vendor Tag:\s*(.*)$/)
    {
      print "Found vendor tag: $1\n";
      $vendor_tag = $1;
    }
    elsif ($importing && $tagging && /^Release Tags:\s*(.*)$/)
    {
      print "Found release tag: $1\n";
      $release_tag = $1;
      $tagging = 0;
      $fileing = 1;
    }
    elsif ($importing && $fileing && /^([UNCIL]) (.*)$/)
    {
      print "Found file: $2 ($1)\n";
      $files{$2}{'name'} = $2;
      $files{$2}{'old'} = "";
      $files{$2}{'new'} = $1;
    }
    elsif ($logging)
    {
      $message .= "$_\n";
    }
    elsif (/^Log Message:$/)
    {
      $logging = 1;
    }
  }

  return $message;
}

#*****************************************************************************
##
## FUNCTION NAME: create_file_message
##
## PARAMETERS   : None.
##
## RETURNS      : The message.
##
## SIDE EFFECTS : None.
##
## DESCRIPTION  : Creates a message with all the files that have been modified
##                and the accompanying log message.
##
##****************************************************************************

sub create_file_message
{
  my($message);
  my($file);
  my($name_max) = 15;
  my($old_max) = 15;
  my($new_max) = 15;
  my(@diff_files);

  foreach $file (sort keys(%files))
  {
    $name_max = length($file) if (length($file) > $name_max);
    $old_max  = length($files{$file}{'old'}) if (length($files{$file}{'old'}) > $old_max);
    $new_max  = length($files{$file}{'new'}) if (length($files{$file}{'new'}) > $new_max);
  }

  my($format) = "%-${name_max}s %-${old_max}s %-${new_max}s %s\n";

  $message =
    "\nThe following " .
    (keys(%files) != 1 ? "files were" : "file was") .
    " modified in $repository:\n\n";

  $message .=
    sprintf($format, "Name", "Old version", "New version", "Comment");
  $message .=
    sprintf($format, "----", "-----------", "-----------", "-------");
  
  foreach $file (sort keys(%files))
  {
    if ($files{$file}{'new'} eq 'U')
    {
      $message .= sprintf($format, $file, "", "", "Updated");
    }
    elsif ($files{$file}{'new'} eq 'N')
    {
      $message .= sprintf($format, $file, "", "", "Added");
    }
    elsif ($files{$file}{'new'} eq 'C')
    {
      $message .= sprintf($format, $file, "", "", "Conflict");
    }
    elsif ($files{$file}{'new'} eq 'I' || $files{$file}{'new'} eq 'L')
    {
      $message .= sprintf($format, $file, "", "", "Ignored");
    }
    elsif ($files{$file}{'old'} eq 'NONE')
    {
      $message .= sprintf($format, $file, "", $files{$file}{'new'}, "Added");
    }
    elsif ($files{$file}{'new'} eq 'NONE')
    {
      $message .= sprintf($format, $file, $files{$file}{'old'}, "", "Removed");
    }
    else
    {
      $message .= sprintf($format, $file, $files{$file}{'old'}, $files{$file}{'new'}, "");
      push(@diff_files, $file);
    }
  }

  $message .= "\nThe accompanying log:\n\n$log";

  # We need to fork, and continue in the child process so that the CVS lock
  # is released before we try to create the diff for the changed files.
  my $status = fork;

  if ($status > 0)
  {
    exit 0; # This is the parent; end it
  }
  elsif (!$status)
  {
#    sleep(10); # Sleep a little to (hopefully) let the commit command finish

    my $diff_cmd;
    my $diff = '';
    foreach $file (@diff_files)
    {
      $diff_cmd =
	"cvs diff -kk -udw -r$files{$file}{'old'} -r$files{$file}{'new'} $file";

      # I do not know why I need to use .= instead of just = below, but
      # unless I do, I only get the first line of the result from `$diff_cmd`.
      my($file_diff) .= `$diff_cmd`;
      $file_diff =~ s/^.*?---/---/s;
      $diff .= $file_diff if ($file_diff =~ /^---/);

      if ($max_diff_lines >= 0 && $diff =~ tr/\n// >= $max_diff_lines)
      {
	$diff = '';
	last;
      }
    }

    if ($diff)
    {
      $message .= "\nThe diff of the modified file(s):\n\n$diff";
    }
  }
  else
  {
    # If the fork failed we continue without trying to do the diff
  }

  # Remove any \r from the generated message
  $message =~ tr/\r//d;
 
  return $message;
}

#*****************************************************************************
##
## FUNCTION NAME: send_mail
##
## PARAMETERS   : $subject    - The subject of the e-mail.
##                $message    - The body of the e-mail.
##                @recipients - The recipients of the e-mail.
##
## RETURNS      : Nothing.
##
## SIDE EFFECTS : None.
##
## DESCRIPTION  : Send an e-mail.
##
##****************************************************************************

sub send_mail
{
  my($subject, $message, @recipients) = @_;
  my $old_path = $ENV{PATH};

  # Make sure /usr/sbin is in the path (probable location of sendmail)
  $ENV{PATH} = "/usr/sbin:" . $ENV{PATH};
  
  if (!open(MAIL, "| sendmail -t -oi"))
  {
    warn("Could not send notification mail: $!\n");
    return;
  }

  my($user_name) = (getlogin || (getpwuid($<))[0]);
  my($true_login_name, $true_full_name) = (getpwnam($user_name))[0, 6];
  $true_full_name =~ s/,.*//;

  print MAIL "From: $true_full_name <$true_login_name>\n";
  print MAIL "To: ", join(', ', @recipients), "\n";
  print MAIL "Subject: $subject\n";
  print MAIL "Mime-Version: 1.0\n";
  print MAIL "Content-Type: text/plain; charset=iso-8859-1\n";
  print MAIL "Content-Transfer-Encoding: quoted-printable\n";

  print MAIL "\n"; # This empty line separates the heading from the body.

  print MAIL encode_qp($message);

  # Send the mail.
  close(MAIL);

  $ENV{PATH} = $old_path;
}

#*****************************************************************************
##
## FUNCTION NAME: encode_qp
##
## PARAMETERS   : $res - The string to encode.
##
## RETURNS      : The encoded string.
##
## SIDE EFFECTS : None.
##
## DESCRIPTION  : Encode a string using quoted-printable encoding.
##
##****************************************************************************

sub encode_qp
{
  my $res = shift;
  $res =~ s/([^ \t\n!-<>-~])/sprintf("=%02X", ord($1))/eg;  # rule #2,#3
  $res =~ s/([ \t]+)$/
    join('', map { sprintf("=%02X", ord($_)) }
	 split('', $1)
	 )/egm;                        # rule #3 (encode whitespace at eol)

  # rule #5 (lines must be shorter than 76 chars, but we are not allowed
  # to break =XX escapes.  This makes things complicated :-( )
  my $brokenlines = "";
  $brokenlines .= "$1=\n"
    while $res =~ s/(.*?^[^\n]{73} (?:
                 [^=\n]{2} (?! [^=\n]{0,1} $) # 75 not followed by .?\n
                |[^=\n]    (?! [^=\n]{0,2} $) # 74 not followed by .?.?\n
                |          (?! [^=\n]{0,3} $) # 73 not followed by .?.?.?\n
		))//xsm;

  "$brokenlines$res";
}

#****************** END OF FILE cvsnotify ************************************
